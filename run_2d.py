# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NuOPJtIO1u4Q_lhcPk3ejq0kcU1XualQ

## **Import library**
"""
from utils.problem import Rastrigin, Rosenbrock, Eggholder, Ackley, PSO

import numpy as np
import logging
## **Implement**


logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

if __name__ == "__main__":
  SEED = 18520185
  PARAM = {
      'w':  0.7298,
      'c1': 1.49618,
      'c2': 1.49618,
      'k': (1 - 0.1) * np.random.random_sample() + 0.1
  }
  # Save .gif directory
  GIF_DIR = 'gif'
  # Save .log directory
  LOG_DIR = 'logs'
  CALLBACK = {
    'Rastrigin':  lambda topology, dimension : Rastrigin(topology,dimension),
    'Rosenbrock': lambda topology, dimension : Rosenbrock(topology,dimension),
    'Eggholder':  lambda topology, dimension : Eggholder(topology,2),
    'Ackley':     lambda topology, dimension : Ackley(topology,2),
  }

  CONFIG = {
    'N': 32,
    'dimension': 2,
    'generation': 50,
    'nExperiments': 1,
    'funcName': ['Rastrigin','Rosenbrock','Eggholder','Ackley'],
    # 'funcName': ['Eggholder'],
    'topology': ['star','ring'],
    'isSaveGif': False,
    'fps': 3,
    'saveGifPath': lambda funcName: f'{GIF_DIR}/{funcName}',
    'saveLogPath': lambda funcName, topology: f'{LOG_DIR}/{funcName}/{funcName.lower()}_{topology}_2D.log'
  }

  for topology in CONFIG['topology']:
    for funcName in CONFIG['funcName']:
      # try:
        with open(CONFIG['saveLogPath'](funcName,topology), 'w') as f:
          funcConfig = {
            'funcName': funcName,
            'topology': topology,
            'N': CONFIG['N'],
            'dimension': CONFIG['dimension'],
            'generation': CONFIG['generation'],
            'nExperiments': CONFIG['nExperiments'],
            'isSaveGif': CONFIG['isSaveGif'],
            'fps:': CONFIG['fps']
          }
          f.write((f"[Experiment] CONFIG: {funcConfig}\n"))
        for i in range (CONFIG['nExperiments']):
          np.random.seed(SEED + i)
          func = CALLBACK[funcName](topology,CONFIG['dimension'])
          pso = PSO(func,paramConfig=PARAM,generation=CONFIG['generation'],N=CONFIG['N'])
          pso.runAll()
          reportContent = f"Run #{str(i + 1).zfill(2)}: {pso.getReport(SEED + i)}\n"
          with open(CONFIG['saveLogPath'](funcName,topology), "a") as f:
            f.write(reportContent)
          # logger.info(f'\t{reportContent}')
          logger.info(f'{funcName}-{topology}\n{reportContent}')
          if (CONFIG['isSaveGif']):
            pso.visualize(savePath=CONFIG['saveGifPath'](funcName),fps=CONFIG['fps'])
      # except:
      #   print(f'Error at {funcName}, {topology} topology')
# def PSO(func,savePath,k=1,N=32,T='ring',G=50):
#   # Step1: Initial swarm
#   particles = [] ## len == N
#   for index in range(N):
#     neighborsIndex = None
#     if (T == 'ring'):
#       if (index == N - 1):
#         neighborsIndex = [index - 1, 0]
#       elif (index == 0):
#         neighborsIndex = [N-1, 1]
#       else:
#         neighborsIndex = [index-1,index+1]
#     particle = Particle(func, index, neighborsIndex)
#     particles.append(particle)
#   currentGeneration = 0
#   bestParticleIndex = np.argmin([particle.current["value"] for particle in particles])
#   bestParticle = particles[bestParticleIndex]

#   genArr = []
#   bestValueArr = []
#   while (currentGeneration < G):
#     # Get all current particle's positions
#     allCurrentPositions = np.array([particle.current['position'] for particle in particles])
#     # print(allCurrentPositions)
#     path = ax[0].scatter(allCurrentPositions[:, 0], allCurrentPositions[:, 1], c='r')
#     # Find global best particle
#     # bestParticleIndex = np.argmin([particle.current["value"] for particle in particles])
#     # bestParticle = particles[bestParticleIndex]
#     # print(bestParticle.current)
#     for particle in particles:
#       # Step2: Update social components
#       if T == 'ring':
#         neighbors = [particles[index] for index in particle.neighborsIndex]
#         # print(particle.neighborsIndex)
#         bestNeighborIndex = np.argmin([x.current["value"] for x in neighbors])
#         particle.updateSocial(neighbors[bestNeighborIndex].current["position"])
#       elif (T == 'star'):
#         bestNeighborIndex = np.argmin([particle.current["value"] for particle in particles])
#         bestNeighbor = particles[bestNeighborIndex]
#         particle.updateSocial(bestNeighbor.current["position"])
#       # Step3: Update State
#       particle.updateCognitive()
#       particle.updateVelocity()
#       particle.updateState()
#       if (particle.current['value'] < bestParticle.current['value']):
#         bestParticle = particle
#     currentGeneration += 1

#     plt.figure(1)
#     genArr.append(currentGeneration)
#     bestValueArr.append(bestParticle.current['value'])
#     ax[1].plot(genArr, bestValueArr, c='g')
#     ax[1].set_title('Best value so far: {0}'.format(bestParticle.current['value']))
#     ax[1].set_xlabel('Generations')
#     ax[1].set_ylabel('Value')
#     # plt.savefig("{}/{}.jpg".format(savePath,currentGeneration))
#     plt.pause(0.05)
#     path.remove()
#     # print(bestParticle.current)

#   print(bestParticle.current)